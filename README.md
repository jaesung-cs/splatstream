# pygs
Python bindings for 3dgs rendering.

This is a more modularized and organized code of my previous c++ project [vkgs](https://github.com/jaesung-cs/vkgs).

This code is being actively developed, so expect some bugs until the codes are stabilized.

![](/media/train.gif)

Animation generated by `pygs`.
```python
import pygs
splats = pygs.load_from_ply("my_splats.ply")
images = pygs.draw(splats, viewmats, Ks, width, height, near=0.1, far=1e3).numpy()  # (C, H, W, 3)
from PIL import Image
for i in range(len(images)):
  Image.fromarray(images[i, :, :, :3]).save(f"image_{i}.png")
```

## Feature Highlights
- Fast speed: rasterization using Graphics capability.
- Memory-efficiency: reuse resources by double buffering.
- Pure Vulkan with very few dependencies. No CUDA required.

## Limitations
- Only importable `.ply` format files, SH degree 3, from the original Gaussian Splatting.
- No gradient computation.
- Rendering image slightly differs from `gsplat` (suspectedly due to splat culling logic, i.e. frustum test, near the camera)
- No package, no distribution yet, need to build from source and install by yourself.

## Requirements
- `VulkanSDK`, with optional components `Volk`, `vma` installed.
  - `MacOS`: `>=1.4.328.1`, becuase `VK_KHR_push_descriptor` is supported by `MoltenVK` since then.
  - others: `>=1.4`
- `cmake`
- Python dependencies
  ```bash
  $ pip install -r requirements.txt
  ```

## Build Python Module
```bash
$ pip install ./binding
```

## Build c++
```bash
$ cmake . -B build
$ cmake --build build --config Release -j
```

## TODO
- [ ] c++ viewer
- [ ] pytorch binding
- [ ] Find reasons for pixel value difference with `gsplat`

## Technical Details

### C++ File Structure
`src/` directory has three components:
- `api`: c++ API wrapper, hiding all Vulkan dependency and exposes the conceptual containers and operations only.
- `core`: main algorithm for rendering Gaussian Splattings, where Vulkan commands for rendering are submitted.
- `gpu`: Vulkan backend, with helping features: object lifetime management, object creation, etc.

### Front-to-Back Rendering
The splats are sorted front-to-back, unlike how general renderers draw transparent objects back-to-front.
This is intended in order to calculate the accumulated alpha.

$$
\begin{align*}
C_i &= C_{i-1} + \alpha_i c_i \prod_{j \lt i} (1 - \alpha_j) = C_{i-1} + (\alpha_i c_i) T_{i-1} \\
T_i &= \prod_{j \le i} (1 - \alpha_j) = (1 - \alpha_i) T_{i-1}
\end{align*}
$$

The equation turns into fragment

$$
\begin{align*}
C &:= \alpha_{dst} C_{src} + 1 \cdot C_{dst}, \quad \quad \quad C_{src} = \alpha_{src} c_{src} \\
\alpha &:= 0 \cdot \alpha_{src} + (1 - \alpha_{src}) \cdot \alpha_{dst}
\end{align*}
$$

This leads to the fragment shader pre-multiplied alpha, and Vulkan blend operation as following:
```c++
color_attachment.srcColorBlendFactor = VK_BLEND_FACTOR_DST_ALPHA;
color_attachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE;
color_attachment.colorBlendOp = VK_BLEND_OP_ADD;
color_attachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;
color_attachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
color_attachment.alphaBlendOp = VK_BLEND_OP_ADD;
```

### Image Format
A pixel color is determined by many small splats, with very small contributions to the pixel.
The image must be in format of `R32G32B32A32_SFLOAT` to blend correctly, where color and alpha values are loaded and stored in every blend operation.
Then, `vkCmdBlitImage` command draws it to another image of `R8G8B8A8_UNORM` format.
Value clipping between range [0, 1] is automatically performed by blitting.

### Double Buffering
...
