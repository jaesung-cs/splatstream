#version 460 core

#extension GL_EXT_shader_16bit_storage : require
#extension GL_KHR_shader_subgroup_arithmetic : enable

layout(local_size_x = 256) in;

layout(push_constant, std430) uniform ProjectionPushConstants {
  mat4 model;
  uint point_count;
  float eps2d;
  uint sh_degree_data;
  uint sh_degree_draw;
  uint record_stat;
};

// TODO: use uniform buffer
layout(std430, binding = 0) readonly buffer Camera {
  mat4 projection;
  mat4 view;
  vec4 camera_position;
  uvec2 screen_size;  // (width, height)
};

layout(std430, binding = 1) readonly buffer GaussianPosition {
  float gaussian_position[];  // (N, 3)
};

layout(std430, binding = 2) readonly buffer GaussianCov3d {
  float gaussian_cov3d[];  // (N, 6)
};

layout(std430, binding = 3) readonly buffer GaussianOpacity {
  float gaussian_opacity[];  // (N)
};

layout(std430, binding = 4) readonly buffer GaussianSh {
  f16vec4 gaussian_sh[];  // (N, K), packed.
};

layout(std430, binding = 5) readonly buffer VisiblePointCount { uint visible_point_count; };

layout(std430, binding = 6) readonly buffer InverseMap {
  int inverse_map[];  // (N), inverse map from id to sorted index
};

layout(std430, binding = 7) writeonly buffer DrawIndirect {
  uint indexCount;
  uint instanceCount;
  uint firstIndex;
  int vertexOffset;
  uint firstInstance;
};

#ifdef VKGS_SHADER_INSTANCES_VEC4
layout(std430, binding = 8) writeonly buffer Instances {
  vec4 instances[];  // (N, 12). 3 for ndc position, 1 padding, 4 for rot scale, 4 for color.
};
#else
layout(std430, binding = 8) writeonly buffer Instances {
  float instances[];  // (N, 11). 3 for ndc position, 4 for rot scale, 4 for color.
};

layout(std430, binding = 9) buffer Stat {
  uint histogram_alpha[64];
  uint histogram_projection_active_threads[64];
};

void main() {
  uint id = gl_GlobalInvocationID.x;
  if (id >= point_count) return;

  if (id == 0) {
    indexCount = 6 * visible_point_count;
    instanceCount = 1;
    firstIndex = 0;
    vertexOffset = 0;
    firstInstance = 0;
  }

  int inverse_id = inverse_map[id];
  if (inverse_id == -1) return;

  vec3 v0 = vec3(gaussian_cov3d[id * 6 + 0], gaussian_cov3d[id * 6 + 1], gaussian_cov3d[id * 6 + 2]);
  vec3 v1 = vec3(gaussian_cov3d[id * 6 + 3], gaussian_cov3d[id * 6 + 4], gaussian_cov3d[id * 6 + 5]);
  vec4 pos = vec4(gaussian_position[id * 3 + 0], gaussian_position[id * 3 + 1], gaussian_position[id * 3 + 2], 1.f);

  float opacity = gaussian_opacity[id];

  mat3x4 sh0, sh1, sh2, sh3;
  vec3 rest;
  if (sh_degree_data == 0) {
    rest = vec4(gaussian_sh[id]).xyz;
  } else if (sh_degree_data == 1) {
    sh0 = mat3x4(gaussian_sh[id * 3 + 0], gaussian_sh[id * 3 + 1], gaussian_sh[id * 3 + 2]);
  } else if (sh_degree_data == 2) {
    sh0 = mat3x4(gaussian_sh[id * 7 + 0], gaussian_sh[id * 7 + 2], gaussian_sh[id * 7 + 4]);
    sh1 = mat3x4(gaussian_sh[id * 7 + 1], gaussian_sh[id * 7 + 3], gaussian_sh[id * 7 + 5]);
    rest = vec4(gaussian_sh[id * 7 + 6]).xyz;
  } else if (sh_degree_data == 3) {
    sh0 = mat3x4(gaussian_sh[id * 12 + 0], gaussian_sh[id * 12 + 4], gaussian_sh[id * 12 + 8]);
    sh1 = mat3x4(gaussian_sh[id * 12 + 1], gaussian_sh[id * 12 + 5], gaussian_sh[id * 12 + 9]);
    sh2 = mat3x4(gaussian_sh[id * 12 + 2], gaussian_sh[id * 12 + 6], gaussian_sh[id * 12 + 10]);
    sh3 = mat3x4(gaussian_sh[id * 12 + 3], gaussian_sh[id * 12 + 7], gaussian_sh[id * 12 + 11]);
  }

  // direction in model space for SH calculation
  vec4 camera_model_position = inverse(model) * camera_position;
  camera_model_position = camera_model_position / camera_model_position.w;
  vec3 dir = normalize(pos.xyz - camera_model_position.xyz);

  // [v0.x v0.y v0.z]
  // [v0.y v1.x v1.y]
  // [v0.z v1.y v1.z]
  mat3 cov3d = mat3(v0, v0.y, v1.xy, v0.z, v1.yz);

  // model-view matrix
  mat3 model_view3d = mat3(view) * mat3(model);
  cov3d = model_view3d * cov3d * transpose(model_view3d);
  pos = view * model * pos;
  pos = pos / pos.w;

  // projection
  mat3x2 J =
      mat2(projection) * mat3x2(1.f / pos.z, 0.f, 0.f, 1.f / pos.z, -pos.x / pos.z / pos.z, -pos.y / pos.z / pos.z);
  mat2 cov2d = J * cov3d * transpose(J);

  // low-pass filter: eps2d = 0.3 (default)
  float det_orig = cov2d[0][0] * cov2d[1][1] - cov2d[1][0] * cov2d[0][1];
  cov2d[0][0] += eps2d * 4.f / screen_size.x / screen_size.x;
  cov2d[1][1] += eps2d * 4.f / screen_size.y / screen_size.y;
  float det_blur = cov2d[0][0] * cov2d[1][1] - cov2d[1][0] * cov2d[0][1];
  float compensation = sqrt(max(det_orig / det_blur, 0.f));

  // eigendecomposition
  // [a c] = [x y]
  // [c b]   [y z]
  float a = cov2d[0][0];
  float b = cov2d[1][1];
  float c = cov2d[1][0];
  float D = sqrt((a - b) * (a - b) + 4.f * c * c);
  float s0 = sqrt(0.5f * (a + b + D));
  float s1 = sqrt(0.5f * (a + b - D));
  // decompose to R S^2 R^T, D=0 for uniform scale S and indeterminate R.
  float theta = D != 0.f ? atan(2. * c, a - b) / 2.f : 0.f;
  float cos_theta = cos(theta);
  float sin_theta = sin(theta);
  // R*S
  mat2 rot_scale = mat2(s0 * cos_theta, s0 * sin_theta, -s1 * sin_theta, s1 * cos_theta);

  pos = projection * pos;
  pos = pos / pos.w;

  // calculate spherical harmonics
  const float C0 = 0.28209479177387814f;
  const float C1 = 0.4886025119029199f;
  const float C20 = 1.0925484305920792f;
  const float C21 = 0.31539156525252005f;
  const float C22 = 0.5462742152960396f;
  const float C30 = 0.5900435899266435f;
  const float C31 = 2.890611442640554f;
  const float C32 = 0.4570457994644658f;
  const float C33 = 0.3731763325901154f;
  const float C34 = 1.445305721320277f;

  mat4 basis = mat4(0.f);
  if (sh_degree_draw == 0) {
    basis[0].x = C0;
  } else if (sh_degree_draw == 1) {
    float x = dir.x;
    float y = dir.y;
    float z = dir.z;
    basis[0] = vec4(C0, -C1 * y, C1 * z, -C1 * x);
  } else if (sh_degree_draw == 2) {
    float x = dir.x;
    float y = dir.y;
    float z = dir.z;
    float xx = x * x;
    float yy = y * y;
    float zz = z * z;
    float xy = x * y;
    float yz = y * z;
    float xz = x * z;
    basis[0] = vec4(C0, -C1 * y, C1 * z, -C1 * x);
    basis[1] = vec4(C20 * xy, -C20 * yz, C21 * (2.f * zz - xx - yy), -C20 * xz);
    basis[2].x = C22 * (xx - yy);
  } else if (sh_degree_draw == 3) {
    float x = dir.x;
    float y = dir.y;
    float z = dir.z;
    float xx = x * x;
    float yy = y * y;
    float zz = z * z;
    float xy = x * y;
    float yz = y * z;
    float xz = x * z;
    basis[0] = vec4(C0, -C1 * y, C1 * z, -C1 * x);
    basis[1] = vec4(C20 * xy, -C20 * yz, C21 * (2.f * zz - xx - yy), -C20 * xz);
    basis[2] = vec4(C22 * (xx - yy), -C30 * y * (3.f * xx - yy), C31 * xy * z, -C32 * y * (4.f * zz - xx - yy));
    basis[3] = vec4(C33 * z * (2.f * zz - 3.f * xx - 3.f * yy), -C32 * x * (4.f * zz - xx - yy), C34 * z * (xx - yy),
                    -C30 * x * (xx - 3.f * yy));
  }

  vec3 color;
  if (sh_degree_data == 0) {
    vec3 sh0 = rest;
    color = basis[0].x * sh0;
  } else if (sh_degree_data == 1) {
    color = basis[0] * sh0;
  } else if (sh_degree_data == 2) {
    color = basis[0] * sh0 + basis[1] * sh1 + basis[2].x * rest;
  } else if (sh_degree_data == 3) {
    color = basis[0] * sh0 + basis[1] * sh1 + basis[2] * sh2 + basis[3] * sh3;
  }

  // translation and clip
  color = max(color + 0.5f, 0.f);
  float alpha = opacity * compensation;

#ifdef VKGS_SHADER_INSTANCES_VEC4
  instances[inverse_id * 3 + 0] = vec4(pos.xyz, 1.f);  // TODO: delete w component
  instances[inverse_id * 3 + 1] = vec4(rot_scale[0], rot_scale[1]);
  instances[inverse_id * 3 + 2] = vec4(color, alpha);
#else
  instances[inverse_id * 11 + 0] = pos.x;
  instances[inverse_id * 11 + 1] = pos.y;
  instances[inverse_id * 11 + 2] = pos.z;
  instances[inverse_id * 11 + 3] = rot_scale[0][0];
  instances[inverse_id * 11 + 4] = rot_scale[0][1];
  instances[inverse_id * 11 + 5] = rot_scale[1][0];
  instances[inverse_id * 11 + 6] = rot_scale[1][1];
  instances[inverse_id * 11 + 7] = color.x;
  instances[inverse_id * 11 + 8] = color.y;
  instances[inverse_id * 11 + 9] = color.z;
  instances[inverse_id * 11 + 10] = alpha;
#endif

  if (record_stat == 1) {
    uint quantized_alpha = clamp(int(alpha * 50.f), 0, 49);
    atomicAdd(histogram_alpha[quantized_alpha], 1);

    uint count = subgroupAdd(1);
    if (subgroupElect()) {
      atomicAdd(histogram_projection_active_threads[count - 1], 1);
    }
  }
}
