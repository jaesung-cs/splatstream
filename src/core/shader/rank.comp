#version 460 core

layout(local_size_x = 256) in;

layout(push_constant, std430) uniform ProjectionPushConstants {
  mat4 model;
  uint point_count;
  uint aligned_point_count;
  uint sh_degree_data;
  uint sh_degree_draw;
  float eps2d;
};

// TODO: use uniform buffer
layout(std430, binding = 0) readonly buffer Camera {
  mat4 projection;
  mat4 view;
  vec4 camera_position;
  uvec2 screen_size;  // (width, height)
};

layout(std430, binding = 1) readonly buffer GaussianPosition {
  float gaussian_position[];  // (N, 3)
};

layout(std430, binding = 2) buffer VisiblePointCount { uint visible_point_count; };

layout(std430, binding = 3) writeonly buffer InstanceKey { uint key[]; };

layout(std430, binding = 4) writeonly buffer InstanceIndex { uint index[]; };

void main() {
  uint id = gl_GlobalInvocationID.x;
  if (id >= point_count) return;

  vec4 pos = vec4(gaussian_position[0 * aligned_point_count + id], gaussian_position[1 * aligned_point_count + id], gaussian_position[2 * aligned_point_count + id], 1.f);
  pos = projection * view * model * pos;
  pos = pos / pos.w;

  // valid only when center is inside NDC clip space.
  // UnscentedTransformParameters.in_image_margin_factor = 0.1, i.e. -0.1 <= x <= 1.1
  // In Vulkan NDC [-1, 1], -1.2 <= x <= 1.2
  if (abs(pos.x) <= 1.2f && abs(pos.y) <= 1.2f && pos.z >= 0.f && pos.z <= 1.f) {
    uint instance_index = atomicAdd(visible_point_count, 1);
    key[instance_index] = floatBitsToUint(1.f - pos.z);
    index[instance_index] = id;
  }
}
