#version 460 core

#extension GL_EXT_shader_16bit_storage : require

layout(local_size_x = 256) in;

layout(push_constant, std430) uniform ParsePushConstant {
  uint point_count;
  uint sh_degree;
  int opacity_degree;
};

layout(std430, binding = 0) readonly buffer Position {
  float position[];  // (N, 3)
};

layout(std430, binding = 1) readonly buffer Quats {
  float quats[];  // (N, 4)
};

layout(std430, binding = 2) readonly buffer Scales {
  float scales[];  // (N, 3)
};

layout(std430, binding = 3) readonly buffer Colors {
  float16_t colors[];  // (N, K, 3)
};

layout(std430, binding = 4) readonly buffer Opacity {
  float opacity[];  // (N), or (N, K). K = 1, 4, 9, or 16.
};

layout(std430, binding = 5) writeonly buffer GaussianPositionOpacity {
  vec4 gaussian_position_opacity[];  // (N, 4)
};

layout(std430, binding = 6) writeonly buffer GaussianCov3d {
  vec4 gaussian_cov3d[];  // (N, 6)
};

layout(std430, binding = 7) writeonly buffer GaussianSh {
  f16vec4 gaussian_sh[];  // (N, X), packed.
};

layout(std430, binding = 8) writeonly buffer GaussianOpacitySh {
  f16vec4 gaussian_opacity_sh[];  // (N, K), packed.
};

void main() {
  uint id = gl_GlobalInvocationID.x;

  if (id < point_count) {
    // calculate covariance
    vec3 s = vec3(scales[3 * id + 0], scales[3 * id + 1], scales[3 * id + 2]);

    // wxyz to xyzw
    vec4 q = vec4(quats[4 * id + 1], quats[4 * id + 2], quats[4 * id + 3], quats[4 * id + 0]);
    q = q / length(q);

    mat3 rot;
    float xx = q.x * q.x;
    float yy = q.y * q.y;
    float zz = q.z * q.z;
    float xy = q.x * q.y;
    float xz = q.x * q.z;
    float yz = q.y * q.z;
    float wx = q.w * q.x;
    float wy = q.w * q.y;
    float wz = q.w * q.z;
    rot[0][0] = 1.f - 2.f * (yy + zz);
    rot[0][1] = 2.f * (xy + wz);
    rot[0][2] = 2.f * (xz - wy);
    rot[1][0] = 2.f * (xy - wz);
    rot[1][1] = 1.f - 2.f * (xx + zz);
    rot[1][2] = 2.f * (yz + wx);
    rot[2][0] = 2.f * (xz + wy);
    rot[2][1] = 2.f * (yz - wx);
    rot[2][2] = 1.f - 2.f * (xx + yy);

    mat3 ss = mat3(0.f);
    ss[0][0] = s[0] * s[0];
    ss[1][1] = s[1] * s[1];
    ss[2][2] = s[2] * s[2];
    mat3 cov3d = rot * ss * transpose(rot);

    float opacity0 = 0.f;
    if (opacity_degree <= 0) {
      opacity0 = opacity[id];
    } else if (opacity_degree == 1) {
      gaussian_opacity_sh[id] = f16vec4(vec4(opacity[4 * id + 0], opacity[4 * id + 1], opacity[4 * id + 2], opacity[4 * id + 3]));
    } else if (opacity_degree == 2) {
      opacity0 = opacity[9 * id + 0];
      gaussian_opacity_sh[2 * id + 0] = f16vec4(vec4(opacity[9 * id + 1], opacity[9 * id + 2], opacity[9 * id + 3], opacity[9 * id + 4]));
      gaussian_opacity_sh[2 * id + 1] = f16vec4(vec4(opacity[9 * id + 5], opacity[9 * id + 6], opacity[9 * id + 7], opacity[9 * id + 8]));
    } else if (opacity_degree == 3) {
      gaussian_opacity_sh[4 * id + 0] = f16vec4(vec4(opacity[16 * id + 0], opacity[16 * id + 1], opacity[16 * id + 2], opacity[16 * id + 3]));
      gaussian_opacity_sh[4 * id + 1] = f16vec4(vec4(opacity[16 * id + 4], opacity[16 * id + 5], opacity[16 * id + 6], opacity[16 * id + 7]));
      gaussian_opacity_sh[4 * id + 2] = f16vec4(vec4(opacity[16 * id + 8], opacity[16 * id + 9], opacity[16 * id + 10], opacity[16 * id + 11]));
      gaussian_opacity_sh[4 * id + 3] = f16vec4(vec4(opacity[16 * id + 12], opacity[16 * id + 13], opacity[16 * id + 14], opacity[16 * id + 15]));
    }

    gaussian_position_opacity[id] = vec4(position[3 * id + 0], position[3 * id + 1], position[3 * id + 2], opacity0);

    gaussian_cov3d[2 * id + 0] = vec4(cov3d[0][0], cov3d[1][0], cov3d[2][0], 0.f);
    gaussian_cov3d[2 * id + 1] = vec4(cov3d[1][1], cov3d[2][1], cov3d[2][2], 0.f);

    if (sh_degree == 0) {
      gaussian_sh[id] = f16vec4(vec4(colors[3 * id + 0], colors[3 * id + 1], colors[3 * id + 2], 0.f));
    } else if (sh_degree == 1) {
      gaussian_sh[3 * id + 0] = f16vec4(vec4(colors[12 * id + 0], colors[12 * id + 3], colors[12 * id + 6], colors[12 * id +  9]));
      gaussian_sh[3 * id + 1] = f16vec4(vec4(colors[12 * id + 1], colors[12 * id + 4], colors[12 * id + 7], colors[12 * id + 10]));
      gaussian_sh[3 * id + 2] = f16vec4(vec4(colors[12 * id + 2], colors[12 * id + 5], colors[12 * id + 8], colors[12 * id + 11]));
    } else if (sh_degree == 2) {
      gaussian_sh[7 * id + 0] = f16vec4(vec4(colors[27 * id +  0], colors[27 * id +  3], colors[27 * id +  6], colors[27 * id +  9]));
      gaussian_sh[7 * id + 1] = f16vec4(vec4(colors[27 * id + 12], colors[27 * id + 15], colors[27 * id + 18], colors[27 * id + 21]));
      gaussian_sh[7 * id + 2] = f16vec4(vec4(colors[27 * id +  1], colors[27 * id +  4], colors[27 * id +  7], colors[27 * id + 10]));
      gaussian_sh[7 * id + 3] = f16vec4(vec4(colors[27 * id + 13], colors[27 * id + 16], colors[27 * id + 19], colors[27 * id + 22]));
      gaussian_sh[7 * id + 4] = f16vec4(vec4(colors[27 * id +  2], colors[27 * id +  5], colors[27 * id +  8], colors[27 * id + 11]));
      gaussian_sh[7 * id + 5] = f16vec4(vec4(colors[27 * id + 14], colors[27 * id + 17], colors[27 * id + 20], colors[27 * id + 23]));
      gaussian_sh[7 * id + 6] = f16vec4(vec4(colors[27 * id + 24], colors[27 * id + 25], colors[27 * id + 26], 0.f));
    } else if (sh_degree == 3) {
      gaussian_sh[12 * id +  0] = f16vec4(vec4(colors[48 * id +  0], colors[48 * id +  3], colors[48 * id +  6], colors[48 * id +  9]));
      gaussian_sh[12 * id +  1] = f16vec4(vec4(colors[48 * id + 12], colors[48 * id + 15], colors[48 * id + 18], colors[48 * id + 21]));
      gaussian_sh[12 * id +  2] = f16vec4(vec4(colors[48 * id + 24], colors[48 * id + 27], colors[48 * id + 30], colors[48 * id + 33]));
      gaussian_sh[12 * id +  3] = f16vec4(vec4(colors[48 * id + 36], colors[48 * id + 39], colors[48 * id + 42], colors[48 * id + 45]));
      gaussian_sh[12 * id +  4] = f16vec4(vec4(colors[48 * id +  1], colors[48 * id +  4], colors[48 * id +  7], colors[48 * id + 10]));
      gaussian_sh[12 * id +  5] = f16vec4(vec4(colors[48 * id + 13], colors[48 * id + 16], colors[48 * id + 19], colors[48 * id + 22]));
      gaussian_sh[12 * id +  6] = f16vec4(vec4(colors[48 * id + 25], colors[48 * id + 28], colors[48 * id + 31], colors[48 * id + 34]));
      gaussian_sh[12 * id +  7] = f16vec4(vec4(colors[48 * id + 37], colors[48 * id + 40], colors[48 * id + 43], colors[48 * id + 46]));
      gaussian_sh[12 * id +  8] = f16vec4(vec4(colors[48 * id +  2], colors[48 * id +  5], colors[48 * id +  8], colors[48 * id + 11]));
      gaussian_sh[12 * id +  9] = f16vec4(vec4(colors[48 * id + 14], colors[48 * id + 17], colors[48 * id + 20], colors[48 * id + 23]));
      gaussian_sh[12 * id + 10] = f16vec4(vec4(colors[48 * id + 26], colors[48 * id + 29], colors[48 * id + 32], colors[48 * id + 35]));
      gaussian_sh[12 * id + 11] = f16vec4(vec4(colors[48 * id + 38], colors[48 * id + 41], colors[48 * id + 44], colors[48 * id + 47]));
    }
  }
}
